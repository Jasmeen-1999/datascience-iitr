{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# CONVERSION FROM ONE BASE TO ANOTHER\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def base_conversion(n,multiplier,base,result):        #using recursion\n",
    "    \n",
    "    digit  = n % 10\n",
    "    n = n // 10\n",
    "    result = result + multiplier * digit\n",
    "    multiplier = multiplier * base\n",
    "    if n == 0:\n",
    "        print (\"Final answer:\" , result)\n",
    "    else: \n",
    "        base_conversion(n,multiplier,base,result)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final answer: 1518\n"
     ]
    }
   ],
   "source": [
    "base_conversion(2756,1,8,0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def base_conversion(n,multiplier,base,result):        #using while loop\n",
    "    while True:\n",
    "        digit  = n % 10\n",
    "        n = n // 10\n",
    "        result = result + multiplier * digit\n",
    "        multiplier = multiplier * base\n",
    "        if n == 0:\n",
    "            print (\"Final answer:\" , result)\n",
    "            break\n",
    "         \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final answer: 1518\n"
     ]
    }
   ],
   "source": [
    "base_conversion(2756,1,8,0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "SYMS = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_\"\n",
    "def convert10tobase(num, base):\n",
    "    if base > len(SYMS) or base < 2:\n",
    "        print(\"Invalid base\")\n",
    "        return None\n",
    "    if num < base:\n",
    "        return SYMS[num]\n",
    "    else:\n",
    "        remainder = num % base\n",
    "        new_num = num // base\n",
    "        result = convert10tobase(new_num, base)\n",
    "        return result + SYMS[remainder]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'1010'"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "convert10tobase(10, 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# TODO: Tower of Hanoi - research"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: Create a condition on x1, x2 and x where print True if x is on the line joining x1 and x2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def is_online(x1, x2, x):\n",
    "    if x1 <= x2 and x >= x1 and x <= x2:\n",
    "        return True\n",
    "    elif x2 <= x1 and x >= x2 and x <= x1:\n",
    "        return True\n",
    "    else: \n",
    "        return False\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "is_online(1, 2, 0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "is_online(1, 2, 1.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "is_online(-1, 2, 1.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "is_online(1, -2, 1.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: Two lines x1 --> x2 and x3 --> x4, print True, if overlapping or touching otherwise print False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def line_overlapping(line1,line2):\n",
    "    line1 = (x1, y1)\n",
    "    line2 = (x2, y2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Bisect or Binary Search\n",
    "# Q: Write SQ method, Write you own code to do SQRT\n",
    "# Q: First write you own method to cube and then do cube root\n",
    "# Q: Tower of Hanoi\n",
    "#Q: A rectangle is represented by two opposite corners. Each corner is represented a two number (x, y). Given two rectangles, return True if they are touching or overlapping otherwise return false.\n",
    "\n",
    "def is_overlapping(fx1,fy1,fx2,fy2,sx1,sy1,sx2,sy2):\n",
    "    return True\n",
    "#Q: pythagoras\n",
    "\n",
    "def hypotenus(b, h):\n",
    "    # ur own sqrt or math.sqrt\n",
    "    return 0\n",
    "#Q: \n",
    "\n",
    "def distance_2d(x1, y1, x2, y2):\n",
    "    return #the distance using hypotenus\n",
    "# Q:\n",
    "\n",
    "def distance_3d(x1, y1, z1, x2, y2, z2):\n",
    "    return #the distance using hypotenus\n",
    "#Q: discuss distance between two point in N dimensions\n",
    "#Q:\n",
    "# # Designing thermometer\n",
    "# when current 1, the teperature was 30\n",
    "# when currrent 2, the temperature was 35\n",
    "# when current will be 3, what would be the temperature 40\n",
    "# current = 4, temp = 45\n",
    "# current 2.1, temp = 35.5\n",
    "Q:\n",
    "# I want to measure the rate of change of output with respect to input.\n",
    "# Slight increase input and observe how much output changes\n",
    "# find out the ratio of change of output wrt input\n",
    "# def diff(f, x):\n",
    "    # rate of change of output wrt input\n",
    "# test this function on your various functions such as cube, 2*x**3 + 5*x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: Write your own algorithm or strategy to find log10. You can use 10**x.\n",
    "  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_log10(n):\n",
    "    if n < 1:\n",
    "        l = -n\n",
    "    else:    \n",
    "        l = 0         #lower limit\n",
    "    u = n         # upper limit\n",
    "    while True:\n",
    "        mid = (l + u)/2\n",
    "        result = 10**mid\n",
    "        diff = abs(result - n)\n",
    "        if diff <= 0.00001:\n",
    "            return mid\n",
    "        if result > n:\n",
    "            u = mid\n",
    "        else:\n",
    "            l = mid\n",
    "        \n",
    "            \n",
    "      "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.722633922472596"
      ]
     },
     "execution_count": 60,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_log10(528)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.000000238418579"
      ]
     },
     "execution_count": 61,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_log10(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.17609024047851562"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_log10(1.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-0.301025390625"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_log10(0.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: Write SQ method, Write you own code to do SQRT"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def square(x):\n",
    "    return x*x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.25"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "square(-0.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def square_root(n):\n",
    "   \n",
    "        \n",
    "    l = 0\n",
    "    u = n\n",
    "    while True:\n",
    "        mid = (l+u)/2\n",
    "        result = mid*mid\n",
    "        diff = abs(result - n)\n",
    "        if diff < 0.000001:\n",
    "            return mid\n",
    "            break\n",
    "        else:\n",
    "            if result > n:\n",
    "                u = mid\n",
    "            else:\n",
    "                l = mid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.000000074505806"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "square_root(25)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: First write you own method to cube and then do cube root"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cube(x):\n",
    "    return x*x*x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "729"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cube(9)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cube_root(n):                         #using while loop\n",
    "   \n",
    "        \n",
    "    l = 0\n",
    "    u = n\n",
    "    while True:\n",
    "        mid = (l+u)/2\n",
    "        result = mid*mid*mid\n",
    "        diff = abs(result - n)\n",
    "        if diff < 0.000001:\n",
    "            return mid\n",
    "            break\n",
    "        else:\n",
    "            if result > n:\n",
    "                u = mid\n",
    "            else:\n",
    "                l = mid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.000000022351742"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cube_root(27)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cube_root(n):                         #using recursion\n",
    "    l = 0\n",
    "    u = n\n",
    "    mid = (l+u)/2\n",
    "    result = mid*mid*mid\n",
    "    diff = abs(result - n)\n",
    "    if diff < 0.000001:\n",
    "        return mid\n",
    "    if result > n:\n",
    "        u = mid\n",
    "    else:\n",
    "        l = mid\n",
    "    cube_root(n)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "ename": "RecursionError",
     "evalue": "maximum recursion depth exceeded in comparison",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRecursionError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-6-444017ab3452>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mcube_root\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m27\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-5-c833fa5e5a41>\u001b[0m in \u001b[0;36mcube_root\u001b[0;34m(n)\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     12\u001b[0m         \u001b[0ml\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmid\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 13\u001b[0;31m     \u001b[0mcube_root\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "... last 1 frames repeated, from the frame below ...\n",
      "\u001b[0;32m<ipython-input-5-c833fa5e5a41>\u001b[0m in \u001b[0;36mcube_root\u001b[0;34m(n)\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     12\u001b[0m         \u001b[0ml\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmid\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 13\u001b[0;31m     \u001b[0mcube_root\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mRecursionError\u001b[0m: maximum recursion depth exceeded in comparison"
     ]
    }
   ],
   "source": [
    "cube_root(27)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: find hypotenuse of a right angled triangle"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "def find_distance(point1, point2):\n",
    "    x1, y1 = point1\n",
    "    x2, y2 = point2\n",
    "    base = x2 - x1\n",
    "    p = y2 - y1\n",
    "    return math.sqrt(base*base + p * p)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.8284271247461903"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_distance((1,2), (3,4))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_hypotenuse(b, h):\n",
    "    return math.sqrt(b*b + h*h)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.0"
      ]
     },
     "execution_count": 72,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_hypotenuse(3, 4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: A rectangle is represented by two opposite corners. Each corner is represented a two number (x, y). Given two rectangles, return True if they are touching or overlapping otherwise return false.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def is_overlapping_rect(rect1, rect2):\n",
    "    p11, p12 = rect1\n",
    "    p21, p22 = rect2\n",
    "    \n",
    "    return True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: Designing thermometer\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "calibration_data = [[1,30], [2,35]]\n",
    "def tell_temp(calibration_data, current):\n",
    "    return temperature\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q: In your number system. Represent you number as list of digits and create a function to add 1 to your number."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "num = [1, 3, 2, 4, 0]\n",
    "def add1_base5(num):\n",
    "    l = []\n",
    "    i = 1 \n",
    "    while True:\n",
    "        b = num[-i]\n",
    "        if b < 4:\n",
    "            n = -1\n",
    "            b = b + 1\n",
    "            l.append(b)\n",
    "            print(l)\n",
    "            num [-i] = l[n+1]\n",
    "            print(num)\n",
    "            break\n",
    "        if b == 4:\n",
    "            b = 0\n",
    "            l.append(b)\n",
    "            print(l)\n",
    "            n = 0\n",
    "            num [-i] = l[n]\n",
    "            print(num)\n",
    "            i = i + 1\n",
    "    return num"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q:Start with [0,0,0,0] keep adding 1 to it untill the lists exhausts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 1, 1, 1]\n"
     ]
    }
   ],
   "source": [
    "l = [0,0,0,0]\n",
    "i = 0\n",
    "while i < len(l):\n",
    "    l[i] = l[i] + 1\n",
    "    i = i + 1\n",
    "print(l)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
